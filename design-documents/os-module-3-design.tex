
\chapter{Design of Module \textit{virtualmemory}}


\section{Initial Functionality}

Describe briefly what you have been given (have started from) at the beginning of the assignment and the way the existing functionality must be extended.

\section{Data Structures and Functions}

Specify the \textit{data structures} and \textit{functions} involved in your solution and what are they used for. Describe in few words the purpose of new added data structures, fields and functions. 

\begin{lstlisting}
	struct existent_data_structure {
		int newField;
	};
	
	struct newDataStructure {
	};
	
	int newFunction();
\end{lstlisting}


\section{Functionality}

Describe \textbf{briefly}, still \textbf{explicitly}, in words and pseudocode the way your solution works. DO NOT INCLUDE detailed code. 

Give examples, if you think they can make your explanation clearer. You are free to use any other techniques (e.g. use-case diagrams, sequence diagrams etc.) that you think can make your explanation clearer. 


\section{Design Decisions}

Justify your design decisions, specify other design alternatives, their advantages and disadvantages and mention the reasons of your choice.  

\section{Tests}

Describe briefly the tests you are intended to run in order to test the functionality of your implementation.

\section{Observations}

You can use this section to mention other things not mentioned in the other sections. 

You can indicate and evaluate, for instance:
\begin{itemize}
	\item the most difficult parts of your assignment and the reasons you think they were so; 
	
	\item the difficulty level of the assignment and if the allocated time was enough or not; 

	\item particular facts or hints you think we should give students to help them solve better the assignment.

\end{itemize}

You can also make suggestions for teacher, relative to the way he can assist more effectively the students.

\section{Stack Growth}
\subsection{Initial Functionality}

The stack is just one page and it can't grow any higher. The stack is at the top of the user
virtual address space.

\subsection{Data Structures and Functions}

We need to allocate more pages for the stack when the stack goes higher. Also we need to
impose some absolute limit so it can not get higher. So we need to detect when a page fault occurred because of the growth of the stack. 

\begin{lstlisting} 
	//process.c

	//Grows the stack. Esp is the stack pointer and size
	//is the size of offset in the new page.
	//Returns true if the stack can grow, false otherwise
	static bool grow_stack( void **esp, size_t size );

	//exception.c

	//Detects if stack generates the page fault. Fault_addr is the 
	//that was accessed to cause the page fault.
	//Returns true if the page fault was generated by the
	//grow of the stack, false otherwise.
	static bool is_stack_page_fault( struct intr_frame *f, void* fault_addr ); 
	
\end{lstlisting}


\subsection{Functionality}
 
\textbf{In page\_fault:}
	  \\1. Get the address that generate the page fault.
	  \\2. Verify if stack cause the page fault by comparing the esp with the page fault address. If the difference between them is 32 or 4 then the page fault was cause by the grow of the stack.
	  \\3. Verify the size of the stack, if the size if higher than 8MB then destroy process.
	  \\4. If true than the call the method stack\_grow
	  \\5. If false continue to determin the reason for the page faul.

\textbf{In file process.c: }

We will create a function that will grow the stack. The function will be something like this:

\begin{lstlisting}
    static bool is_stack_page_fault( struct intr_frame *f, void* fault_addr )
    {
      \\1. Alloc new page from user pool.
      \\2. If the page is not null, try to connect the page frame with the virtual page. The address of the virtual page where page fault occures is connected with the frame page.
      \\3. If is not possible to connect them dealloc the page and return faslse.
      \\4. Returns true is everthing works.
    }
\end{lstlisting}


\subsection{Design Decisions}

We had to modified the method page\_fault because here we can see the cause of the page fault. Also in this method are tested other possible causes of the page fault. And add a new method in the file process.c named stack\_grow because in this file the stack is initialize and this method depends on the process.


\subsection{Tests}

The following tests are: 

\textbf{pt-grow-stk-obj} - Allocates and writes to 64 kB objects on the stack. 

\textbf{pt-grow-bad} - Reads from an address 4,096 bytes below stack pointer. 

\textbf{pt-grow-pusha} - Expand the stack by 32 bytes all at once using PUSHA instruction. 

\textbf{pt-grow-stack} - Demonstrate that the stack can grow. 

\textbf{pt-grow-stk-sc} - This test checks that the stack is properly extended even if the first access to a stack location occurs inside a system call. 



\section{Memory Mapped Files}
\subsection{Initial Functionality}

We have open/read/write file syscalls. We know for each process its table of opened files.


\subsection{Data Structures and Functions}

We need the following data structures and functions for managing memory mapped files: 

\begin{lstlisting}
	//process.h
	struct process_t {
		list mmap_list;
	};

	typedef int mapid_t;
	struct mapped_file {
		mapid_t id;
		int fd;
		void *user_provided_location;
		size_t file_size;
		enum mapped_file_status status; //optional
		struct list_elem lst;
	};

	//syscall.c
	static void syscall_mmap(struct intr_frame *f);
	static void syscall_munmap(struct intr_frame *f);
\end{lstlisting}
	


\subsection{Functionality}

\subsubsection{ syscall\_mmap }
\textbf{In syscall\_mmap:}
	\\1. Check if the fd is valid.
	\\2. Inform the pages starting from the user provided address that they valid, and not present. We should also check if they aren't used already.
	\\3. If there is no error, make a mapped\_file entry and add it to the current process list.
	\\4. Return the id.
	\\5. We should add/increment a reference to the fd table such that the file is not truly closed until nothing references it anymore.



	\textbf{Somewhere in swap:}
	\\1. We check if the evicted page provided belongs to a memory mapped file. If yes we write that page on the harddisk. Careful with page/file bounds.
	\\2. If the requested page belongs to a memory mapped file, we just read it from the harddisk. Fill with 0s the padding if necessary.

The memory mapped file page checking could be done in the following way: We know the current process in swap/evict because it's inside an exception handler, thus we know how to get to the mapped\_file's list. We simply make range search on each mapped\_file element, since we know that the files are mapped in contiguous regions.

As follows:
\begin{lstlisting}	
	/* may return null when the mapped file is not present  */
	mapped_file *GetMappedFileFromPagePointer(void *pagePointer) {
		process_t *cp = process_current();
		
		foreach (mmentry : cp->mmap_list) {
			if(mmentry->pagePointer < 
				user_provided_location 
				 && user_provided_location < 
					mmentry->pagePointer + 
						mmentry->file_size) {
				return mmentry;
			}
		}
		return NULL;
	}
\end{lstlisting}
	3. The evict/add\_page\_from\_hdd could find out, by using this function what to do next.

\subsubsection{ syscall\_munmap }
\textbf{In syscall\_munmap:}
	\\1. Write what's in the memory to the file. 
	\\2. Remove the mmentry from the list.

	 \textbf{In process\_exit:}
	\\1. Call munmap for each entry in the process mmap\_list;


\subsection{Design Decisions}
We keep the mapped file list in each process because it's easier to manage the lifetime of the list entries. It's also a performance gain because if we would use a global list, searching could become very slow for a process that doesn't own any mapped files. That searching is done inside an exception handler! An alternative to this would be to use the supplemental page table to hold the necessary data.
\\When unmapping we could forcibly evict all the pages that belong to the file instead of in place writing.
\subsection{Tests}
All the mmap from tests/vm.


\textbf{mmap-bad-fd} - Tries to mmap an invalid fd, which must either fail silently or terminate the process with exit code -1.


\textbf{mmap-clean} - Verifies that mmap'd regions are only written back on munmap if the data was actually modified in memory.


\textbf{mmap-close} - Verifies that memory mappings persist after file close.


\textbf{mmap-exit} - Executes child-mm-wrt and verifies that the writes that should  have occurred really did.


\textbf{mmap-inherit} - Maps a file into memory and runs child-inherit to verify that  mappings are not inherited.


\textbf{mmap-misalign} - Verifies that misaligned memory mappings are disallowed.


\textbf{mmap-null} - Verifies that memory mappings at address 0 are disallowed.


\textbf{mmap-over-code} - Verifies that mapping over the code segment is disallowed.


\textbf{mmap-over-data} - Verifies that mapping over the data segment is disallowed.


\textbf{mmap-overlap} - Verifies that overlapping memory mappings are disallowed.


\textbf{mmap-over-stk} - Verifies that mapping over the stack segment is disallowed.


\textbf{mmap-read} - Uses a memory mapping to read a file.


\textbf{mmap-remove} - Deletes and closes file that is mapped into memory and verifies that it can still be read through the mapping.


\textbf{mmap-shuffle} - Creates a 128 kB file and repeatedly shuffles data in it through a memory mapping.


\textbf{mmap-twice} - Maps the same file into memory twice and verifies that the same data is readable in both.


\textbf{mmap-unmap} - Maps and unmaps a file and verifies that the mapped region is inaccessible afterward.


\textbf{mmap-write} - Writes to a file through a mapping, and unmaps the file, then reads the data in the file back using the read system call to verify.


\textbf{mmap-zero} - Tries to map a zero-length file, which may or may not work but  should not terminate the process or crash.  Then dereferences the address that we tried to map, and the process must be terminated with -1 exit code. 









	

