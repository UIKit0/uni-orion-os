
\chapter{Design of Module \textit{virtualmemory}}


\section{Paging}

At the beginning of this project, it is not possible to load programs that are bigger than the memory size of the system. To be able to do this we want to implement virtual memory in pintos. The most important issue that has to be solved in order to implement virtual memory in pintos is Paging. At this moment, pintos organizes the memory in pages, but it has the following limitations:
\begin{itemize}
 \item the whole executable is loaded at run-time 
 \item the whole executable is unloaded at end of run
\end{itemize}

In order to remove this limitations this part will implement the following three sub parts:
\begin{itemize}
  \item lazy-loading of executables - only a part of executable is loaded at run-time
  \item	eviction - unused parts of executable are unloaded from memory even if the program is running
  \item swap - temporary buffer for pages that were modified since loading and are chosen for eviction
\end{itemize}

\section{Data Structures and Functions}

\textbf{Eviction}

\begin{lstlisting}

  //In frame.h:

  struct frame
  {
	//kernel virtual address of page
	void *kpage; 	
	  
	//user virtual address of page
	void *upage;	
	
	//if frame is pinned, the contained page can not be evicted
	bool  pinned;		
	
	struct hash_elem he; //needed for hash_table
  };

  /*allocates a page within a frame
    and returns the allocated frame
    if there is an unused frame.
    Otherwise, it tries to evict a 
    frame and return it. If no frame
    is unused and no frame can be evicted
    it returns NULL. */
  frame* ft_aloc_frame(void *upage);
  
  //initializes the frame-table
  void	 ft_init();

  //In frame.c:
  /* The frametable */
  static struct hash frame_table;

  /*hash function for the frame table.
  It should be computed using the kpage field
  of the frame */
  static unsigned frame_hash (const struct hash_elem *f_, void *aux UNUSED);
  
  /* Frame table utility functions */
  static bool frame_less (const struct hash_elem *a_, const struct hash_elem *b_, void *aux UNUSED);
  frame* frame_lookup (const void *kpage);

  /* A lock for frame_table synch access*/
  struct lock ft_lock;

  /*
    Finds the least recently used frame
  */
  frame* ft_get_lru_frame();

\end{lstlisting}

\section{Functionality}

\textbf{Eviction}

\begin{lstlisting}

  //In process.c: Change palloc_get_page with ft_alloc_frame

  ft_alloc_frame(void *upage_addr) : returns a frame*
    void *kpage = palloc_get_page(upage_addr);
    if(kpage != NULL) {
      frame *f = malloc(sizeof frame)
      f.kpage = kpage;
      f.upage = upage;
      f.pinned = ...
      f.he = ...
      insert_hash(f.he);
      return f;
    }
    else {
      frame *lru_f = ft_get_lru_frame();
      if lru_f != NULL
	return lru_f
    }

    return NULL;

  ft_get_lru_frame() : returns a frame*
    //first iteration
    for each frame in frame_table
      if ( !pagedir_is_accessed_or_dirty(thread_current()->pagedir, frame.upage) )
	continue;
      else 
	evict(frame);
	return frame;
    
    for each frame in frame_table
      if ( !pagedir_is_accessed(thread_current()->pagedir, frame.upage) )
	continue;
      else 
	evict(frame);
	return frame;

  
\end{lstlisting}



\section{Design Decisions}

\textbf{Eviction}

We chose to implement the frame table as a hash map. Other options would have been a vector or a list. The problem of the vector is that it would occuppy the same space whether the frame table is full or not. However the benefit of the vector is that it has constant access by index. The list, on the other side occuppies less space than the vector in the when the memory is not occupied, but does not provide constant access. Therefore, we chose to implement the frame table as a hash map.

Altough normally a frame table maps a physical address to a virtual address we chose the key of the frame table to be a virtual kernel address, the kernel virtual address, because of the strong correlation in pintos between the physical address and the kernel virtual address.

\section{Tests}

Describe briefly the tests you are intended to run in order to test the functionality of your implementation.

\section{Observations}

You can use this section to mention other things not mentioned in the other sections. 

You can indicate and evaluate, for instance:
\begin{itemize}
	\item the most difficult parts of your assignment and the reasons you think they were so; 
	
	\item the difficulty level of the assignment and if the allocated time was enough or not; 

	\item particular facts or hints you think we should give students to help them solve better the assignment.

\end{itemize}

You can also make suggestions for teacher, relative to the way he can assist more effectively the students.

\section{Stack Growth}
\subsection{Initial Functionality}

The stack is just one page and it can't grow any higher. The stack is at the top of the user
virtual address space.

\subsection{Data Structures and Functions}

We need to allocate more pages for the stack when the stack goes higher. Also we need to
impose some absolute limit so it can not get higher. So we need to detect when a page fault occurred because of the growth of the stack. 

\begin{lstlisting} 

	//thread.h

	//add a new field esp that will holds the stack pointer
	//when an exception causes a switch from user mode to
	//kernel mode
	struct thread {
	  ...
	  void* esp;
	};

	//process.c

	//Grows the stack. Esp is the stack pointer and size
	//is the size of offset in the new page.
	//Returns true if the stack can grow, false otherwise
	static bool grow_stack( void **esp, size_t size );

	//exception.c

	//Detects if stack generates the page fault. Fault_addr is the 
	//that was accessed to cause the page fault.
	//Returns true if the page fault was generated by the
	//grow of the stack, false otherwise.
	static bool is_stack_page_fault( struct intr_frame *f, 
					 void* fault_addr ); 
	
\end{lstlisting}


\subsection{Functionality}
 
\textbf{In syscal\_handler:}
	  \\1. Save the stack pointer in the struct thread

\textbf{In page\_fault:}
	  \\1. Get the address that generate the page fault.
	  \\2. Verify if stack cause the page fault by comparing the esp from current with the page fault address. If the difference between them is 32 or 4 then the page fault was cause by the grow of the stack.
	  \\3. Verify the size of the stack, if the size if higher than 8MB then destroy process.
	  \\4. If true than the call the method stack\_grow
	  \\5. If false continue to determin the reason for the page faul.

\textbf{In file process.c: }

We will create a function that will grow the stack. The function will be something like this:

\begin{lstlisting}
    static bool is_stack_page_fault( struct intr_frame *f, void* fault_addr )
    {
      \\1. Alloc new page from user pool.
      \\2. If the page is not null, try to connect the page frame with the virtual page. The address of the virtual page where page fault occures is connected with the frame page.
      \\3. If is not possible to connect them dealloc the page and return faslse.
      \\4. Returns true is everthing works.
    }
\end{lstlisting}


\subsection{Design Decisions}

We had to modified the method page\_fault because here we can see the cause of the page fault. Also in this method are tested other possible causes of the page fault. And add a new method in the file process.c named stack\_grow because in this file the stack is initialize and this method depends on the process.


\subsection{Tests}

The following tests are: 

\textbf{pt-grow-stk-obj} - Allocates and writes to 64 kB objects on the stack. 

\textbf{pt-grow-bad} - Reads from an address 4,096 bytes below stack pointer. 

\textbf{pt-grow-pusha} - Expand the stack by 32 bytes all at once using PUSHA instruction. 

\textbf{pt-grow-stack} - Demonstrate that the stack can grow. 

\textbf{pt-grow-stk-sc} - This test checks that the stack is properly extended even if the first access to a stack location occurs inside a system call. 



\section{Memory Mapped Files}
\subsection{Initial Functionality}

We have open/read/write file syscalls. We know for each process its table of opened files.


\subsection{Data Structures and Functions}

We need the following data structures and functions for managing memory mapped files: 

\begin{lstlisting}
	//process.h
	struct process_t {
		list mmap_list;
	};

	typedef int mapid_t;
	struct mapped_file {
		mapid_t id;
		int fd;
		void *user_provided_location;
		size_t file_size;
		enum mapped_file_status status; //optional
		struct list_elem lst;
	};

	//syscall.c
	static void syscall_mmap(struct intr_frame *f);
	static void syscall_munmap(struct intr_frame *f);
\end{lstlisting}
	


\subsection{Functionality}

\subsubsection{ syscall\_mmap }
\textbf{In syscall\_mmap:}
	\\1. Check if the fd is valid.
	\\2. Inform the pages starting from the user provided address that they valid, and not present. We should also check if they aren't used already.
	\\3. If there is no error, make a mapped\_file entry and add it to the current process list.
	\\4. Return the id.
	\\5. We should add/increment a reference to the fd table such that the file is not truly closed until nothing references it anymore.



	\textbf{Somewhere in swap:}
	\\1. We check if the evicted page provided belongs to a memory mapped file. If yes we write that page on the harddisk. Careful with page/file bounds.
	\\2. If the requested page belongs to a memory mapped file, we just read it from the harddisk. Fill with 0s the padding if necessary.

The memory mapped file page checking could be done in the following way: We know the current process in swap/evict because it's inside an exception handler, thus we know how to get to the mapped\_file's list. We simply make range search on each mapped\_file element, since we know that the files are mapped in contiguous regions.

As follows:
\begin{lstlisting}	
	/* may return null when the mapped file is not present  */
	mapped_file *GetMappedFileFromPagePointer(void *pagePointer) {
		process_t *cp = process_current();
		
		foreach (mmentry : cp->mmap_list) {
			if(mmentry->pagePointer < 
				user_provided_location 
				 && user_provided_location < 
					mmentry->pagePointer + 
						mmentry->file_size) {
				return mmentry;
			}
		}
		return NULL;
	}
\end{lstlisting}
	3. The evict/add\_page\_from\_hdd could find out, by using this function what to do next.

\subsubsection{ syscall\_munmap }
\textbf{In syscall\_munmap:}
	\\1. Write what's in the memory to the file. 
	\\2. Remove the mmentry from the list.

	 \textbf{In process\_exit:}
	\\1. Call munmap for each entry in the process mmap\_list;


\subsection{Design Decisions}
We keep the mapped file list in each process because it's easier to manage the lifetime of the list entries. It's also a performance gain because if we would use a global list, searching could become very slow for a process that doesn't own any mapped files. That searching is done inside an exception handler! An alternative to this would be to use the supplemental page table to hold the necessary data.
\\When unmapping we could forcibly evict all the pages that belong to the file instead of in place writing.
\subsection{Tests}
All the mmap from tests/vm.


\textbf{mmap-bad-fd} - Tries to mmap an invalid fd, which must either fail silently or terminate the process with exit code -1.


\textbf{mmap-clean} - Verifies that mmap'd regions are only written back on munmap if the data was actually modified in memory.


\textbf{mmap-close} - Verifies that memory mappings persist after file close.


\textbf{mmap-exit} - Executes child-mm-wrt and verifies that the writes that should  have occurred really did.


\textbf{mmap-inherit} - Maps a file into memory and runs child-inherit to verify that  mappings are not inherited.


\textbf{mmap-misalign} - Verifies that misaligned memory mappings are disallowed.


\textbf{mmap-null} - Verifies that memory mappings at address 0 are disallowed.


\textbf{mmap-over-code} - Verifies that mapping over the code segment is disallowed.


\textbf{mmap-over-data} - Verifies that mapping over the data segment is disallowed.


\textbf{mmap-overlap} - Verifies that overlapping memory mappings are disallowed.


\textbf{mmap-over-stk} - Verifies that mapping over the stack segment is disallowed.


\textbf{mmap-read} - Uses a memory mapping to read a file.


\textbf{mmap-remove} - Deletes and closes file that is mapped into memory and verifies that it can still be read through the mapping.


\textbf{mmap-shuffle} - Creates a 128 kB file and repeatedly shuffles data in it through a memory mapping.


\textbf{mmap-twice} - Maps the same file into memory twice and verifies that the same data is readable in both.


\textbf{mmap-unmap} - Maps and unmaps a file and verifies that the mapped region is inaccessible afterward.


\textbf{mmap-write} - Writes to a file through a mapping, and unmaps the file, then reads the data in the file back using the read system call to verify.


\textbf{mmap-zero} - Tries to map a zero-length file, which may or may not work but  should not terminate the process or crash.  Then dereferences the address that we tried to map, and the process must be terminated with -1 exit code. 









	

